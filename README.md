# dolm [![Build Status](https://travis-ci.org/yishn/dolm.svg?branch=master)](https://travis-ci.org/yishn/dolm)

A tiny internationalization library.

## Installation

Use npm to install:

~~~js
$ npm install dolm
~~~

## Guide

### Simple Strings

Specify your strings as an object with the default text as the key, and the translated text as value.

~~~js
let strings = {
  simple: {
    "Hello World!": "Hallo Welt!",
    "Goodbye": "Auf Wiedersehen"
  }
}
~~~

The string object is wrapped around the key `simple`, which is called the *context* of the translation. You can specify an arbitrary string as the context of a strings object. You can also have multiple contexts.

To get the translation function of a context, use:

~~~js
const dolm = require('dolm').load(strings)

let t = dolm.context('simple')

t('Hello World!')
// => "Hallo Welt!"

t('Goodbye')
// => "Auf Wiedersehen"
~~~

If a key is not found, dolm will fall back to the default text:

~~~js
t('Good morning') // Key not found
// => "Good morning"
~~~

### Complex Strings

You can also specify functions in the strings object. Using so-called *complex strings* you can use interpolation and formatting inside translated text.

~~~js
let strings = {
  simple: {
    "Hello World!": "Hallo Welt!",
    "Goodbye": "Auf Wiedersehen"
  },
  complex: {
    "My name is ${name}": p => `Ich heiße ${p.name}`,
    "I have ${count} apples": p => `Ich habe ${['keine Äpfel', 'einen Apfel'][p.count] || `${p.count} Äpfel`}`
  }
}
~~~

If you use complex strings, you have to pay special attention to the key. They will be generated by the default implementation, i.e. be determined when you call the translation function. It's best to let dolm generate a template strings object with its [serialization](#serialization) feature.

It's theoretically possible that two different default implementations generate the same key, which may cause issues, but in practice, this is rarely a problem.

~~~js
let t = dolm.context('complex')

t(p => `My name is ${p.name}`, {name: 'Yichuan'})
// => "Ich heiße Yichuan"

t(p => `I have ${['no apples', 'one apple'][p.count] || `${p.count} apples`}`, {count: 1})
// => "Ich habe einen Apfel"
~~~

As with simple strings, the default implementation will be used when the translation is missing.
